<html>
<head>
<title>week02/D/411422089_D.c</title>
</head>
<body bgcolor="white">
<hr/>
week02/D/411422089_D.c<p></p><pre>
#include &lt;stdio.h&gt;

int main() {
    int t;
    scanf("%d", &amp;t); // 幾筆資料

    while (t--) {
        int n=0, k=0;
        //printf("start\n");
        scanf("%d%d", &amp;n, &amp;k); // 單位數量和除數
        //printf("n1 = %d\nk=%d\n", n, k);

<a name="0"></a><font color="#FF0000"><a href="match59-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

        int minOps = k; // 初始化最小操作次数为 k
</font><a name="0"></a><font color="#FF0000"><a href="match59-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

        int flag = 1; // 假设所有单位的魔力值都能被 k 整除
</font>        int two_counter = 0;
        int one_counter = 0;

        int arr[200001];
        for(int i=0;i&lt;n;i++)
        {
            scanf("%d", &amp;arr[i]);
        }

        for (int i = 0; i &lt; n; i++) {
            int ai = arr[i];
            //scanf("%d", &amp;ai); // 單位的魔力值

            if (ai % k ==0){ // 一有單位整除則跳出迴圈
                minOps = 0;
                flag = 1;
                break;
            }
            if(k == 4 &amp;&amp; (ai % k == 2) ){
                two_counter++;
                if(two_counter &gt;= 2){
                /////////////////////////////
                    flag = 1 ;
                    break;
                }
            }
            if(k == 4)
            {
                if(ai % k == 1)
                {
                    one_counter++;
                }
                if(two_counter&gt;=1 &amp;&amp; one_counter&gt;0)
                {
                    if(minOps&gt;1)
                        minOps = 1;
                }
                if(one_counter&gt;=2)
                {
                    if(minOps&gt;2)
                        minOps = 2;
                }
            }

            if (ai % k != 0) {
                flag = 0; // 如果有任意一个单位的魔力值不能被 k 整除，更新标志位
                int ops = k - (ai % k); // 计算需要增加的次数
                if (ops &lt; minOps) {
                    minOps = ops; // 更新最小操作次数
                }
            }
        }

        if (flag) {
            minOps = 0; // 如果所有单位的魔力值都能被 k 整除，最小操作次数为 0
        }

        printf("%d\n", minOps); // 输出最小操作次数
    }

    return 0;
}
</pre>
</body>
</html>
